<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TeddyCraft — Climb & Build</title>
<style>
  :root{
    --ink:#e7eef7; --muted:#a8b2c7; --bg:#0b0f14; --panel:#141b22; --accent:#ff6b00;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif}
  #ui {position:fixed;inset:12px auto auto 12px; z-index:10; display:flex; gap:8px; align-items:center;}
  .badge{background:rgba(0,0,0,.35);border:1px solid #223243;border-radius:10px;padding:8px 12px;color:var(--muted);backdrop-filter:blur(6px);font-size:14px}
  #hotbar{position:fixed; left:50%; bottom:16px; transform:translateX(-50%); display:flex; gap:8px; z-index:10;}
  .slot{width:48px; height:48px; border-radius:10px; border:2px solid #2a3b4e; display:grid; place-items:center; font-weight:700}
  .slot.sel{border-color:var(--accent); box-shadow:0 0 16px rgba(255,107,0,.35)}
  .dirt{background:#7a4a2a}
  .stone{background:#6b6f7d}
  .wood{background:#8b5a2b}
  #help{position:fixed; right:12px; top:12px; z-index:10;}
  #help details{background:rgba(0,0,0,.35);border:1px solid #223243;border-radius:10px;padding:8px 12px;color:var(--muted);max-width:420px}
  #pause{position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.35); z-index:20}
  #pause.show{display:grid}
  #pause .card{background:var(--panel); border:1px solid #223243; border-radius:16px; padding:20px; text-align:center; max-width:420px}
  #pause button{background:var(--accent); border:none; color:#111; padding:10px 14px; border-radius:10px; font-weight:800; cursor:pointer}
  canvas{display:block; width:100vw; height:100vh; image-rendering: pixelated; }
</style>
</head>
<body>
  <div id="ui">
    <div class="badge">WASD / ⬅⬆⬇➡ to move · Space to jump · Hold into wall + ↑ to climb · Click to place · Right-click to remove · 1/2/3 to change block · P to pause</div>
  </div>
  <div id="help">
    <details>
      <summary>Controls & Tips</summary>
      <ul>
        <li><b>Move:</b> A/D or ⬅/➡</li>
        <li><b>Jump:</b> Space (or W/↑)</li>
        <li><b>Climb walls:</b> Hold toward a wall + Up; climb speed is slower than walking.</li>
        <li><b>Place block:</b> Left click within reach (6 tiles).</li>
        <li><b>Remove block:</b> Right click (or Shift+Left click).</li>
        <li><b>Hotbar:</b> 1 Dirt · 2 Stone · 3 Wood</li>
        <li><b>Save/Load:</b> World auto-saves to your browser.</li>
      </ul>
    </details>
  </div>
  <div id="hotbar">
    <div class="slot dirt sel" data-type="1">1</div>
    <div class="slot stone" data-type="2">2</div>
    <div class="slot wood" data-type="3">3</div>
  </div>
  <div id="pause"><div class="card">
    <h2>Paused</h2>
    <p>Press <b>P</b> to resume.</p>
    <p style="color:var(--muted)">Your world is saved locally.</p>
    <div style="display:flex; gap:10px; justify-content:center; margin-top:10px;">
      <button id="resumeBtn">Resume</button>
      <button id="resetBtn" style="background:#e85d5d;color:#111">Reset World</button>
    </div>
  </div></div>

  <canvas id="game"></canvas>

<script>
(() => {
  // ====== Config ======
  const TILE = 24;                  // px per tile
  const W = Math.floor(window.innerWidth / TILE);
  const H = Math.floor(window.innerHeight / TILE);
  const WORLD_W = Math.max(128, W + 32);
  const WORLD_H = Math.max(80, H + 32);
  const GRAVITY = 0.5;
  const JUMP_VELOCITY = -9.5;
  const MOVE_SPEED = 3.2;
  const CLIMB_SPEED = 1.8;          // vertical climb speed
  const MAX_FALL = 14;
  const REACH = 6;                  // tiles distance for place/remove
  const AIR=0, DIRT=1, STONE=2, WOOD=3;
  const SAVE_KEY = "teddycraft_world_v1";

  // ====== State ======
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const off = document.createElement("canvas");
  const offCtx = off.getContext("2d");

  let scaleX=1, scaleY=1;
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    scaleX = 1; scaleY = 1;
  }
  resize(); window.addEventListener("resize", resize);

  // World grid
  let world = new Uint8Array(WORLD_W * WORLD_H);

  function idx(x,y){ return y*WORLD_W + x; }
  function inBounds(x,y){ return x>=0 && y>=0 && x<WORLD_W && y<WORLD_H; }

  function generateWorld() {
    world.fill(AIR);
    // Simple heightmap ground
    let base = Math.floor(WORLD_H*0.7);
    let height = Array(WORLD_W).fill(base);
    let h = base;
    for (let x=0; x<WORLD_W; x++){
      // mild noise
      h += (Math.random() < 0.5 ? -1 : 1) * (Math.random()<0.2?1:0);
      h = Math.max(base-4, Math.min(base+3, h));
      height[x]=h;
      for (let y=h; y<WORLD_H; y++){
        world[idx(x,y)] = (y>h+3) ? STONE : DIRT;
      }
    }
    // sprinkle pillars
    for(let i=0;i<50;i++){
      let x = 10 + Math.floor(Math.random()*(WORLD_W-20));
      let y = height[x]-1;
      let tall = 2 + Math.floor(Math.random()*6);
      for(let t=0;t<tall;t++){
        if (inBounds(x,y-t)) world[idx(x,y-t)] = WOOD;
      }
    }
  }

  function saveWorld(){
    try {
      localStorage.setItem(SAVE_KEY, JSON.stringify({
        w: WORLD_W, h: WORLD_H,
        data: Array.from(world),
        player: {x:px, y:py}
      }));
    } catch(e){}
  }
  function loadWorld(){
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return false;
      const obj = JSON.parse(raw);
      if (obj.w!==WORLD_W || obj.h!==WORLD_H) return false;
      world = Uint8Array.from(obj.data);
      px = obj.player?.x ?? px;
      py = obj.player?.y ?? py;
      return true;
    } catch(e){ return false; }
  }

  // Player
  let px = 10, py = 10;
  let vx = 0, vy = 0;
  let onGround = false;
  let climbing = false;
  let facing = 1;

  // Camera
  let camX = 0, camY = 0;

  // Input
  const keys = new Set();
  let mouse = {x:0,y:0, gridX:0, gridY:0, left:false, right:false}
  window.addEventListener("keydown", e=>{
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if (e.key === "p" || e.key==="P") togglePause();
    if (e.key === "1") setBlock(DIRT);
    if (e.key === "2") setBlock(STONE);
    if (e.key === "3") setBlock(WOOD);
  }, {passive:false});
  window.addEventListener("keyup", e=>keys.delete(e.key.toLowerCase()));

  canvas.addEventListener("mousemove", e=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });
  canvas.addEventListener("mousedown", e=>{
    if (e.button===0) mouse.left=true;
    if (e.button===2) mouse.right=true;
  });
  canvas.addEventListener("contextmenu", e=>e.preventDefault());
  window.addEventListener("mouseup", e=>{
    if (e.button===0) mouse.left=false;
    if (e.button===2) mouse.right=false;
  });

  // Hotbar selection UI
  let currentBlock = DIRT;
  function setBlock(t){
    currentBlock = t;
    document.querySelectorAll(".slot").forEach(el=>el.classList.remove("sel"));
    const sel = document.querySelector(`.slot[data-type="${t}"]`);
    if (sel) sel.classList.add("sel");
  }
  document.querySelectorAll(".slot").forEach(el=>{
    el.addEventListener("click", ()=> setBlock(parseInt(el.dataset.type,10)));
  });

  // Pause
  let paused = false;
  const pauseEl = document.getElementById("pause");
  function togglePause(){
    paused = !paused;
    pauseEl.classList.toggle("show", paused);
  }
  document.getElementById("resumeBtn").onclick = togglePause;
  document.getElementById("resetBtn").onclick = ()=>{
    generateWorld();
    px=10; py=10; vx=0; vy=0;
    saveWorld();
    togglePause();
  }

  // World init
  generateWorld();
  loadWorld();

  // ====== Physics & Helpers ======
  function solidAt(x, y) {
    // x,y in world coordinates (floating). Convert to tile.
    const tx = Math.floor(x);
    const ty = Math.floor(y);
    if (!inBounds(tx,ty)) return true; // treat out-of-bounds as solid
    const t = world[idx(tx,ty)];
    return t !== AIR;
  }

  function collideAndSlide(px, py, vx, vy){
    // Basic AABB of player is 0.8 x 0.95 tiles
    const w = 0.8, h = 0.95;
    let nx = px + vx * dt;
    let ny = py + vy * dt;

    // Horizontal
    if (vx > 0){
      const right = Math.floor(nx + w/2);
      if (solidAt(right, py - h/2) || solidAt(right, py) || solidAt(right, py + h/2)){
        nx = right - (w/2) - 1e-6;
        vx = 0;
      }
    } else if (vx < 0){
      const left = Math.floor(nx - w/2);
      if (solidAt(left, py - h/2) || solidAt(left, py) || solidAt(left, py + h/2)){
        nx = left + 1 + (w/2) + 1e-6;
        vx = 0;
      }
    }

    // Vertical
    if (vy > 0){
      const bottom = Math.floor(ny + h/2);
      if (solidAt(px - w/2, bottom) || solidAt(px, bottom) || solidAt(px + w/2, bottom)){
        ny = bottom - (h/2) - 1e-6;
        vy = 0;
        onGround = true;
      } else {
        onGround = false;
      }
    } else if (vy < 0){
      const top = Math.floor(ny - h/2);
      if (solidAt(px - w/2, top) || solidAt(px, top) || solidAt(px + w/2, top)){
        ny = top + 1 + (h/2) + 1e-6;
        vy = 0;
      }
    } else {
      // when purely horizontal, update onGround probe
      const bottom = Math.floor(ny + h/2 + 0.05);
      onGround = (solidAt(px - w/2, bottom) || solidAt(px, bottom) || solidAt(px + w/2, bottom));
    }

    // Climbing: allowed if pressing into a wall and up, and there is a wall adjacent.
    const pressingLeft = keys.has("a") || keys.has("arrowleft");
    const pressingRight = keys.has("d") || keys.has("arrowright");
    const pressingUp = keys.has("w") || keys.has("arrowup");
    const wallLeft = solidAt(Math.floor(px - w/2 - 0.05), Math.floor(py));
    const wallRight = solidAt(Math.floor(px + w/2 + 0.05), Math.floor(py));
    climbing = false;
    if (pressingUp && ((pressingLeft && wallLeft) || (pressingRight && wallRight))) {
      // If there's space above, allow climb
      vy = -CLIMB_SPEED;
      climbing = true;
    }

    return {nx, ny, vx, vy};
  }

  function placeOrRemove() {
    // Convert mouse to world tile under cursor
    const tx = Math.floor(mouseWorldX());
    const ty = Math.floor(mouseWorldY());
    if (!inBounds(tx,ty)) return;

    const dist = Math.hypot(tx - px, ty - py);
    if (dist > REACH) return;

    const isShift = keys.has("shift");
    const remove = mouse.right || (mouse.left && isShift);

    if (remove) {
      // Never remove 'out of world' and avoid removing below floor bounding area outside
      if (world[idx(tx,ty)] !== AIR) {
        world[idx(tx,ty)] = AIR;
        saveWorld();
      }
      mouse.right = false; // one-shot
      return;
    }

    if (mouse.left && !isShift) {
      // avoid placing inside player body
      const w = 0.8, h = 0.95;
      const insidePlayer =
        (tx+0.5 > px - w/2 && tx+0.5 < px + w/2) &&
        (ty+0.5 > py - h/2 && ty+0.5 < py + h/2);
      if (!insidePlayer && world[idx(tx,ty)]===AIR) {
        world[idx(tx,ty)] = currentBlock;
        saveWorld();
      }
      mouse.left = false; // one-shot
    }
  }

  function mouseWorldX(){ return (camX + mouse.x) / TILE; }
  function mouseWorldY(){ return (camY + mouse.y) / TILE; }

  // ====== Render ======
  function drawTile(t, x, y){
    // x,y in tiles
    const px = x*TILE - camX;
    const py = y*TILE - camY;
    switch (t) {
      case DIRT:   ctx.fillStyle = "#7a4a2a"; break;
      case STONE:  ctx.fillStyle = "#6b6f7d"; break;
      case WOOD:   ctx.fillStyle = "#8b5a2b"; break;
      default:     return;
    }
    ctx.fillRect(px, py, TILE, TILE);
    // subtle variant noise
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.fillRect(px, py, TILE, 3);
  }

  function drawWorld(){
    // visible bounds
    const x0 = Math.max(0, Math.floor(camX / TILE) - 1);
    const y0 = Math.max(0, Math.floor(camY / TILE) - 1);
    const x1 = Math.min(WORLD_W, Math.ceil((camX + canvas.width)/TILE) + 1);
    const y1 = Math.min(WORLD_H, Math.ceil((camY + canvas.height)/TILE) + 1);
    for (let y=y0; y<y1; y++){
      for (let x=x0; x<x1; x++){
        const t = world[idx(x,y)];
        if (t !== AIR) drawTile(t,x,y);
      }
    }
  }

  function drawPlayer(){
    const w = TILE*0.8, h = TILE*0.95;
    const x = px*TILE - camX - w/2;
    const y = py*TILE - camY - h/2;
    ctx.fillStyle = climbing ? "#ffd166" : "#4cc9f0";
    ctx.fillRect(x, y, w, h);
    // face
    ctx.fillStyle = "#111";
    const eyeY = y + h*0.35;
    if (facing >= 0) {
      ctx.fillRect(x + w*0.65, eyeY, 3, 3);
    } else {
      ctx.fillRect(x + w*0.3, eyeY, 3, 3);
    }
  }

  function drawCursor(){
    const tx = Math.floor(mouseWorldX());
    const ty = Math.floor(mouseWorldY());
    if (!inBounds(tx,ty)) return;
    const dist = Math.hypot(tx - px, ty - py);
    const pxl = tx*TILE - camX, pyl = ty*TILE - camY;
    ctx.strokeStyle = dist <= REACH ? "rgba(255,255,255,0.9)" : "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    ctx.strokeRect(pxl+0.5, pyl+0.5, TILE-1, TILE-1);
  }

  // ====== Game Loop ======
  let last = performance.now();
  let dt = 1/60;

  function step(ts){
    const elapsed = Math.min(50, ts - last);
    last = ts;
    dt = elapsed / 16.6667; // normalize to ~60fps units

    if (!paused) update();
    render();
    requestAnimationFrame(step);
  }

  function update(){
    // Movement input
    const left  = keys.has("a") || keys.has("arrowleft");
    const right = keys.has("d") || keys.has("arrowright");
    const up    = keys.has("w") || keys.has("arrowup");
    const jump  = keys.has(" ") || up;

    vx = 0;
    if (left)  { vx -= MOVE_SPEED; facing = -1; }
    if (right) { vx += MOVE_SPEED; facing =  1; }

    // Gravity unless actively climbing
    if (!climbing) {
      vy += GRAVITY;
      if (vy > MAX_FALL) vy = MAX_FALL;
    }

    // Jump if grounded
    if (jump && onGround) {
      vy = JUMP_VELOCITY;
      onGround = false;
    }

    // Resolve movement & collisions
    const c = collideAndSlide(px, py, vx, vy);
    px = c.nx; py = c.ny; vx = c.vx; vy = c.vy;

    // Place/remove
    placeOrRemove();

    // Camera follows
    camX = px*TILE - canvas.width/2;
    camY = py*TILE - canvas.height/2;
    camX = Math.max(0, Math.min(camX, WORLD_W*TILE - canvas.width));
    camY = Math.max(0, Math.min(camY, WORLD_H*TILE - canvas.height));

    // Autosave occasionally
    if ((Math.random()<0.01)) saveWorld();
  }

  function render(){
    // Background gradient-ish
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const grd = ctx.createLinearGradient(0,0,0,canvas.height);
    grd.addColorStop(0, "#0b0f14");
    grd.addColorStop(1, "#081018");
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawWorld();
    drawPlayer();
    drawCursor();
  }

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
